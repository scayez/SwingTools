## Overview

The `SwingData` and `SwingBatch` classes are designed to extract, integrate, and plot synchrotron data from HDF5 files. They leverage libraries such as **pyFAI** for azimuthal integration and **fabio** for reading image data. The code also supports saving integration results to text files and generating summary plots and videos.

An additional class `Mask` is also implemented to allow the defintion of masks to be applied to detector images.
---

## Classes
### 1. Mask
**Purpose:**
The Mask class can be used to generate mask files in a format compatible with the library. It can handle 2 type of files:
- *.txt files, corresponding to maks files generated by foxtrot. The method convertfoxtrotmask() can be used to convert the mask in the suitable 'edf' format
- *.h5 files corresponding to data file from Swing. The method drawmask() uses the scattering data as input of pyFAI-drawmask so that the user can generate its own mask. 

An instance is created by typing

mask=Mask(filepath)

**Key Methods:**
####'draw_mask()'
This method opens pyFAI-drawmask GUI to create your own mask file, in a format compatible with the library. Do not forget to save the mask on your drive before closing pyFAI-drawmask.

**Parameters:**
path to nxs/h5 file used to create a mask file in the suitable format using pyFAI-drawmask

####'convertfoxtrotmask()'
This method converts foxtrot masks (*.txt) files in the suitable *.edf format.

**Parameters**
path to foxtrot mask


### 2. SwingData

**Purpose:**
Class to manipulate individual files, which may contain several frames
- Extract experimental parameters and images from an HDF5 file.
- Perform azimuthal integration on the Eiger detector data.
- Save integration results and generate plots.

A SwingData instance can be initialized with the following parameters:
- filename: str : path to data faile (*.h5 or *.nxs)
- maskfile: str : path to mask file (*.edf format)
- basler_coords: tuple:  pixel coordinates of X-ray beam on basler image, provided by the beamline scientist on request (don't forget to ask!)
- basler_calibration: tuple calibration of basler image (in µm/pixels), along X and along Z (don't forget to ask if you intend to make XZ mapping)
- anisotropic_data: bool Set True top optimize integration of anisotropic data (slow down computation), (default= False)
- sectors: List(tuple) List of angular sectors to perform azimuthal integration [(angle, delta)] (default=None, corresponds to isotropic averaging)
- average_frames: bool Tag to perform averaging of scattering frames contained in h5 file (default = True)
- transmission_correction: bool Tag to perform intensity normalizatin and transmission corrections (default=True)

Anisotropic data are submitted to additional operations, including:
- caving: detector frames are reconstructed using inversion symmetry. This operation allows to partially suppress the beamstop, dead pixels and eventually detector dead zones if the scattering is centered in the detector (usually not the case to maximize angular coverage). A new mask file is generated and automatically applied to account for these changes.
- integration of 2D maps allowing to perform additional analysis of azimuthal profiles for instance (not yet implemented in the library).

**Key Methods:**
####'save_integration()'
This method will save integration results as .txt files in a subdirectory called integration. Filenames include the sample’s reduced filename, sector information, and frame number if applicable.

In the case of anisotropic data, an additional directory is created, which contains 2D maps data. For each frame, these 2D maps can be recomputed by using 3 files (each of them contains q, or chi or I data, single column files).

#### `plot_data()`
Creates plots that combine:
- The **Basler image** (with a marker at the measurement point).
- The **Eiger mean image** with an overlay of the chi-map for the selected sector.
- A **log–log plot** of the integrated intensity versus *q*.

In the case of anisotropic data, the 2D map q,chi intensity is also plotted.

#### `plot_and_save()`
Performs methods save_integration() and plot-data() in a single command.



### 2. SwingBatch

**Purpose:**

- Process a batch of HDF5 files using the `SwingData` class.
- Provide progress feedback.
- Generate text file outputs for integration results.
- Create a video from the generated plot images.
- 
A SwingBatch instance can be initialized with the following parameters:
- datadir: str : path to directory where *.h5 or *.nxs files are stored
- maskfile: str : path to mask file (*.edf format)
- basler_coords: tuple:  pixel coordinates of X-ray beam on basler image, provided by the beamline scientist on request (don't forget to ask!)
- basler_calibration: tuple calibration of basler image (in µm/pixels), along X and along Z (don't forget to ask if you intend to make XZ mapping)
- anisotropic_data: bool Set True top optimize integration of anisotropic data (slow down computation), (default= False)
- sectors: List(tuple) List of angular sectors to perform azimuthal integration [(angle, delta)] (default=None, corresponds to isotropic averaging)
- average_frames: bool Tag to perform averaging of scattering frames contained in h5 file (default = True)
- transmission_correction: bool Tag to perform intensity normalizatin and transmission corrections (default=True)
- log_file: str Name of the log file (default= "processing_log.txt")
- 
**Key Methods:**

#### `process()`
Iterates over all HDF5 files in the directory and processes each file (extraction, integration, saving results, plotting). Displays progress in the terminal or in a Jupyter Notebook.

#### `create_video_from_images(output_filename="output_video.mp4", fps=3)`
Combines the generated plot images (stored in the "plots" folder) into an MP4 video.

#### `_process_single_file(file_path)`
Processes one file by instantiating `SwingData`, performing integration, saving the results, and generating plots.

#### `get_h5_files()`
Returns a list of HDF5 files in the specified data directory.

#### `_log_results()`
Writes a log file summarizing the processing (which files succeeded and which failed, with error details).

#### `get_report()`
Returns a text report summarizing the processing results.

#### `create_video_from_images(output_filename="output_video.mp4", fps=10)`
Combines the generated plot images (stored in the "plots" folder) into an MP4 video.

---

### 3. **TextFileProcessor**

**Purpose:**

- This class is designed to load, store, and process data from text files in the Foxtrot format.
- It supports loading multiple files with different `skiprows` values to find the correct data, retrieving stored data, and subtracting data from two files.

---

**Key Methods:**

#### `__init__(self)`
Initializes the `TextFileProcessor` object with an empty dictionary to store the file data.

**Parameters:**
- No parameters for initialization.

#### `load_txt(self, path)`
Loads q and i data from a Foxtrot-format text file, attempting different `skiprows` values.

**Parameters:**
- `path`: The file path of the text file to load.

**Returns:**
- `(q, i)`: The q and i data arrays if the file is successfully loaded, otherwise `None, None`.

**Details:**
- The method tries different values of `skiprows` (from 0 to 99) to load the file. If successful, it stores the data in a dictionary (`self.files`), with the file path as the key and the `(q, i)` tuple as the value.

#### `get_data(self, path)`
Retrieves the stored q and i data for a given file path.

**Parameters:**
- `path`: The file path of the text file.

**Returns:**
- `(q, i)`: The stored q and i data if the file is found, otherwise `(None, None)`.

#### `subtract_files(self, file1, file2)`
Subtracts data from two files and saves the result in a new file inside a `sub` subdirectory.

**Parameters:**
- `file1`: The first file to subtract from.
- `file2`: The second file to subtract.

**Returns:**
- None. The result is saved as a new text file in the `sub` folder.

**Details:**
- The method retrieves the data from `file1` and `file2`. If the `q` values are different, it performs interpolation to match them.
- The subtraction of `i` values is done element-wise (`i1 - i2_interpolated`).
- The result is saved in a new text file, with the name formatted as `file1_name-file2_name_subtracted.txt`.

---
